# Subagent Implementation Examples
## Real-World Code Generation & Refactoring Patterns

This document provides concrete before/after examples showing what each subagent can generate or refactor.

---

## 1. API Route Architect Examples

### Before: Manual, Inconsistent Route
```typescript
// /api/tasks/[id]/status/route.ts (BEFORE - inconsistent)
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db/client'
import { tasks } from '@/lib/db/schema'
import { eq } from 'drizzle-orm'

export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } },
) {
  try {
    const body = await request.json()
    const taskId = params.id
    const { status } = body

    // ✗ Missing session validation!
    // ✗ Missing rate limit check!
    // ✗ No request schema validation
    // ✗ Missing user scope (anyone can update any task!)

    if (!status) {
      return NextResponse.json(
        { error: 'Status is required' },
        { status: 400 },
      )
    }

    const result = await db
      .update(tasks)
      .set({ status })
      .where(eq(tasks.id, taskId))  // ✗ SECURITY ISSUE: No userId check!
      .returning()

    // ✗ Dynamic values in response (leaks taskId)
    return NextResponse.json({
      message: `Task ${taskId} updated to ${status}`,
      task: result,
    })
  } catch (error) {
    // ✗ Logs error.message (leaks internals)
    console.error(`Error: ${error instanceof Error ? error.message : 'Unknown'}`)
    return NextResponse.json({ error: 'Failed' }, { status: 500 })
  }
}
```

### After: Subagent-Generated Route (Secure & Consistent)
```typescript
// /api/tasks/[id]/status/route.ts (AFTER - generated by API Route Architect)
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db/client'
import { tasks, updateTaskStatusSchema } from '@/lib/db/schema'
import { eq, and } from 'drizzle-orm'
import { getServerSession } from '@/lib/session/get-server-session'
import { checkRateLimit } from '@/lib/utils/rate-limit'

export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } },
) {
  try {
    // ✓ 1. Session validation
    const session = await getServerSession()
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // ✓ 2. Rate limiting
    const rateLimit = await checkRateLimit(session.user)
    if (!rateLimit.allowed) {
      return NextResponse.json(
        {
          error: 'Rate limit exceeded',
          remaining: rateLimit.remaining,
          resetAt: rateLimit.resetAt.toISOString(),
        },
        { status: 429 },
      )
    }

    // ✓ 3. Request validation with Zod
    const body = await request.json()
    const validatedData = updateTaskStatusSchema.parse(body)
    const taskId = params.id

    // ✓ 4. User-scoped query (prevents cross-user access)
    const [updatedTask] = await db
      .update(tasks)
      .set({
        status: validatedData.status,
        updatedAt: new Date(),
      })
      .where(
        and(
          eq(tasks.id, taskId),
          eq(tasks.userId, session.user.id), // ✓ Security: User scope
        ),
      )
      .returning()

    // ✓ Check if task exists and belongs to user
    if (!updatedTask) {
      return NextResponse.json(
        { error: 'Task not found' },
        { status: 404 },
      )
    }

    // ✓ 5. Static-string logging only
    await logger.info('Task status updated')

    // ✓ 6. Standardized response (no dynamic values)
    return NextResponse.json({
      data: updatedTask,
      message: 'Status updated successfully',
    })
  } catch (error) {
    // ✓ Static-string error logging
    const logger = createTaskLogger(params.id)
    await logger.error('Failed to update task status')

    // Handle specific error types
    if (error instanceof ZodError) {
      return NextResponse.json(
        {
          error: 'Invalid request data',
          details: error.errors.map(e => ({
            path: e.path.join('.'),
            message: e.message,
          })),
        },
        { status: 400 },
      )
    }

    return NextResponse.json(
      { error: 'Failed to update task status' },
      { status: 500 },
    )
  }
}
```

### Key Improvements
| Issue | Before | After |
|-------|--------|-------|
| Session validation | ✗ Missing | ✓ getServerSession() |
| Rate limiting | ✗ Missing | ✓ checkRateLimit() |
| Request validation | ✗ Manual | ✓ Zod schema |
| User scoping | ✗ None (SECURITY BUG) | ✓ userId filter |
| Logging | ✗ Dynamic (leaks data) | ✓ Static strings |
| Error handling | ✗ Generic | ✓ Type-specific handling |
| Response format | ✗ Inconsistent | ✓ Standardized |
| Error messages | ✗ Leaks internals | ✓ Safe, actionable |

---

## 2. Database Schema Optimizer Examples

### Before: Manual Schema + Queries
```typescript
// BEFORE: Schema in schema.ts (incomplete)
export const taskArtifacts = pgTable('task_artifacts', {
  id: text('id').primaryKey(),
  taskId: text('task_id'),  // ✗ No foreign key constraint
  filePath: text('file_path'),
  fileSize: integer('file_size'),
  // ✗ Missing userId (security issue)
  // ✗ Missing createdAt
  // ✗ No soft delete
  // ✗ No encryption for sensitive data
})

// BEFORE: Manual queries scattered across routes
// /api/tasks/[id]/artifacts/route.ts
const artifacts = await db.query.taskArtifacts.findMany({
  where: (ta) => eq(ta.taskId, taskId),
})
// ✗ No userId check - anyone can see any task's artifacts!
// ✗ No type safety - could return wrong fields
```

### After: Subagent-Generated Schema + Queries
```typescript
// AFTER: Schema in schema.ts (generated by Database Optimizer)
export const taskArtifacts = pgTable(
  'task_artifacts',
  {
    id: text('id').primaryKey(),
    // ✓ User scoping
    userId: text('user_id')
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' }),
    // ✓ Task relationship
    taskId: text('task_id')
      .notNull()
      .references(() => tasks.id, { onDelete: 'cascade' }),
    // ✓ File metadata
    fileName: text('file_name').notNull(),
    filePath: text('file_path').notNull(),
    fileSize: integer('file_size').notNull(),
    mimeType: text('mime_type'), // e.g., 'application/pdf'
    // ✓ Artifact type
    artifactType: text('artifact_type', {
      enum: ['screenshot', 'log', 'output', 'report', 'other'],
    }).notNull(),
    // ✓ Soft delete
    deletedAt: timestamp('deleted_at'),
    // ✓ Timestamps
    createdAt: timestamp('created_at').defaultNow().notNull(),
    updatedAt: timestamp('updated_at').defaultNow().notNull(),
  },
  (table) => ({
    // ✓ Indexes for common queries
    userIdIdx: index('task_artifacts_user_id_idx').on(table.userId),
    taskIdIdx: index('task_artifacts_task_id_idx').on(table.taskId),
    userTaskIdx: uniqueIndex('task_artifacts_user_task_idx').on(
      table.userId,
      table.taskId,
    ),
  }),
)

// ✓ Zod schemas (auto-generated)
export const insertTaskArtifactSchema = z.object({
  id: z.string().optional(),
  userId: z.string().min(1),
  taskId: z.string().min(1),
  fileName: z.string().min(1),
  filePath: z.string().min(1),
  fileSize: z.number().int().positive(),
  mimeType: z.string().optional(),
  artifactType: z.enum(['screenshot', 'log', 'output', 'report', 'other']),
  createdAt: z.date().optional(),
  updatedAt: z.date().optional(),
})

export const selectTaskArtifactSchema = z.object({
  id: z.string(),
  userId: z.string(),
  taskId: z.string(),
  fileName: z.string(),
  filePath: z.string(),
  fileSize: z.number(),
  mimeType: z.string().nullable(),
  artifactType: z.enum(['screenshot', 'log', 'output', 'report', 'other']),
  deletedAt: z.date().nullable(),
  createdAt: z.date(),
  updatedAt: z.date(),
})

// ✓ Query helpers (auto-generated)
// lib/db/queries.ts
export async function getTaskArtifacts(taskId: string, userId: string) {
  return db
    .select()
    .from(taskArtifacts)
    .where(
      and(
        eq(taskArtifacts.taskId, taskId),
        eq(taskArtifacts.userId, userId), // ✓ User scope
        isNull(taskArtifacts.deletedAt), // ✓ Exclude deleted
      ),
    )
    .orderBy(desc(taskArtifacts.createdAt))
}

export async function createArtifact(data: InsertTaskArtifact) {
  return db
    .insert(taskArtifacts)
    .values(data)
    .returning()
}

export async function deleteArtifact(id: string, userId: string) {
  // ✓ Soft delete (doesn't actually delete, sets deletedAt)
  return db
    .update(taskArtifacts)
    .set({ deletedAt: new Date() })
    .where(
      and(
        eq(taskArtifacts.id, id),
        eq(taskArtifacts.userId, userId),
      ),
    )
    .returning()
}

// ✓ Migration file (auto-generated)
// lib/db/migrations/0003_add_task_artifacts.sql
CREATE TABLE task_artifacts (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  task_id TEXT NOT NULL,
  file_name TEXT NOT NULL,
  file_path TEXT NOT NULL,
  file_size INTEGER NOT NULL,
  mime_type TEXT,
  artifact_type TEXT NOT NULL,
  deleted_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMP DEFAULT NOW() NOT NULL,

  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
);

CREATE INDEX task_artifacts_user_id_idx ON task_artifacts(user_id);
CREATE INDEX task_artifacts_task_id_idx ON task_artifacts(task_id);
CREATE UNIQUE INDEX task_artifacts_user_task_idx ON task_artifacts(user_id, task_id);
```

### API Route Using Generated Helpers
```typescript
// /api/tasks/[id]/artifacts/route.ts (Using generated helpers)
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } },
) {
  const session = await getServerSession()
  if (!session?.user?.id) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

  // ✓ Use generated helper (user scope built-in)
  const artifacts = await getTaskArtifacts(params.id, session.user.id)

  return NextResponse.json({ data: artifacts })
}
```

### Key Improvements
| Aspect | Before | After |
|--------|--------|-------|
| Foreign keys | ✗ Manual | ✓ Auto-created |
| User scoping | ✗ Missing (SECURITY) | ✓ Built into table |
| Soft delete | ✗ None | ✓ deletedAt field |
| Indexes | ✗ None | ✓ Common queries optimized |
| Type safety | ✗ Manual schemas | ✓ Auto-generated Zod |
| Query helpers | ✗ Scattered | ✓ Centralized, reusable |
| Migrations | ✗ Manual SQL | ✓ Auto-generated |

---

## 3. Security Enforcer Examples

### Before: Security Issues
```typescript
// ✗ VIOLATION 1: Dynamic value in log
await logger.info(`Task created with ID: ${taskId}`)

// ✗ VIOLATION 2: Error details leaked
catch (error) {
  console.error(`Auth failed: ${error.message}`)  // Leaks internal error
}

// ✗ VIOLATION 3: No encryption on sensitive field
export const apiEndpoints = pgTable('api_endpoints', {
  id: text('id').primaryKey(),
  userId: text('user_id'),
  baseUrl: text('base_url'),  // ✗ Should be encrypted!
})

// ✗ VIOLATION 4: Unscoped query
const allTasks = await db.select().from(tasks)  // Anyone's tasks!

// ✗ VIOLATION 5: Credential in console
console.log('GitHub token:', githubToken)
```

### After: Security Enforcer Refactored
```typescript
// ✓ FIXED 1: Static-string logging
await logger.info('Task created')

// ✓ FIXED 2: Safe error handling
catch (error) {
  await logger.error('Authentication failed')  // No details
  return NextResponse.json(
    { error: 'Authentication failed' },
    { status: 401 },
  )
}

// ✓ FIXED 3: Encrypted sensitive field
export const apiEndpoints = pgTable('api_endpoints', {
  id: text('id').primaryKey(),
  userId: text('user_id'),
  baseUrl: text('base_url').notNull(),  // Plain text (not sensitive)
  apiKey: text('api_key').notNull(),    // ✓ This should be encrypted
  // Add encryption handling in application layer
})

// ✓ FIXED 4: Scoped query
const userTasks = await db
  .select()
  .from(tasks)
  .where(eq(tasks.userId, session.user.id))  // ✓ Filtered by user

// ✓ FIXED 5: No credential logging
await logger.info('Authenticating with GitHub')  // Safe, no token
```

### Audit Report Example
```markdown
## Security Audit Report - AA Coding Agent
**Date:** 2026-01-15
**Severity:** 2 Critical, 5 High, 8 Medium

### Critical Issues

#### 1. Unscoped Database Query
**File:** `app/api/tasks/route.ts:156`
**Severity:** Critical
**Issue:** Query missing userId filter
```typescript
// CURRENT (WRONG)
const task = await db.select().from(tasks).where(eq(tasks.id, taskId))

// SHOULD BE
const task = await db.select().from(tasks)
  .where(and(eq(tasks.id, taskId), eq(tasks.userId, user.id)))
```

#### 2. Dynamic Value in Log
**File:** `lib/sandbox/creation.ts:48`
**Severity:** Critical
**Issue:** Task ID leaks in log message
```typescript
// CURRENT (WRONG)
await logger.info(`Processing task: ${taskId}`)

// SHOULD BE
await logger.info('Processing task')
```

### High Issues

#### 1. Unencrypted API Key Field
**File:** `lib/db/schema.ts:200`
**Severity:** High
**Issue:** `connectors.oauthClientSecret` not encrypted
**Fix:** Apply encryption in application layer (lib/crypto.ts)

...etc
```

---

## 4. Sandbox Lifecycle Manager Examples

### Before: Inconsistent Error Handling
```typescript
// ✗ BEFORE: Each agent handles errors differently
// lib/sandbox/agents/claude.ts
export async function executeClaudeInSandbox(...) {
  try {
    // ... 500+ lines of code
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',  // ✗ No retry
    }
  }
}

// lib/sandbox/agents/codex.ts
export async function executeCodexInSandbox(...) {
  // ✗ Completely different error handling approach
  if (!result.success) {
    await logger.error(`Codex failed: ${result.error}`)  // ✗ Dynamic logging
    throw new Error(result.error)
  }
}
```

### After: Unified Error Handling
```typescript
// ✓ AFTER: Consistent error recovery pattern
// lib/sandbox/agents/base.ts (new - generated by Lifecycle Manager)

export interface AgentError extends Error {
  type: 'transient' | 'permanent' | 'auth' | 'timeout'
  retryable: boolean
  message: string
}

/**
 * Determine if error should be retried based on type
 */
function isRetryableError(error: unknown): boolean {
  if (error instanceof AgentError) {
    return error.retryable && error.type === 'transient'
  }
  if (error instanceof Error) {
    const msg = error.message.toLowerCase()
    return (
      msg.includes('econnrefused') ||
      msg.includes('etimedout') ||
      msg.includes('getaddrinfo') ||
      msg.includes('temporarily unavailable')
    )
  }
  return false
}

/**
 * Execute agent with exponential backoff retry
 */
export async function executeWithRetry<T>(
  operation: () => Promise<T>,
  options = { maxRetries: 3, initialDelayMs: 1000 },
): Promise<T> {
  let lastError: Error | undefined

  for (let attempt = 0; attempt <= options.maxRetries; attempt++) {
    try {
      return await operation()
    } catch (error) {
      lastError = error as Error

      if (!isRetryableError(error) || attempt === options.maxRetries) {
        throw error
      }

      const delayMs = options.initialDelayMs * Math.pow(2, attempt)
      await logger.info(`Retry attempt ${attempt + 1} of ${options.maxRetries}`)  // ✓ Static
      await new Promise(resolve => setTimeout(resolve, delayMs))
    }
  }

  throw lastError
}

// ✓ Usage in all agents (unified)
export async function executeClaudeInSandbox(...) {
  return executeWithRetry(async () => {
    // ... agent implementation
  }, { maxRetries: 3 })
}

export async function executeCodexInSandbox(...) {
  return executeWithRetry(async () => {
    // ... agent implementation
  }, { maxRetries: 3 })
}
```

### Session Resumption Unified
```typescript
// ✓ Session management (unified across all agents)
// lib/sandbox/session-manager.ts (generated)

export async function getSessionId(taskId: string): Promise<string | null> {
  const task = await db.select({ agentSessionId: tasks.agentSessionId })
    .from(tasks)
    .where(eq(tasks.id, taskId))
  return task[0]?.agentSessionId || null
}

export async function saveSessionId(taskId: string, sessionId: string): Promise<void> {
  await db.update(tasks)
    .set({ agentSessionId: sessionId })
    .where(eq(tasks.id, taskId))

  await logger.info('Session ID saved')  // ✓ Static
}

export async function resumeSession(
  sandbox: Sandbox,
  taskId: string,
  instruction: string,
): Promise<AgentResult> {
  const sessionId = await getSessionId(taskId)

  if (!sessionId) {
    return { success: false, error: 'No session found' }
  }

  await logger.info('Resuming session')  // ✓ Static

  // Agent uses sessionId to resume
  return executeWithRetry(async () => {
    // ... resume logic specific to agent
  })
}
```

---

## 5. React Component Examples

### Before: Inconsistent Components
```typescript
// ✗ BEFORE: Custom form without validation
// components/task-form.tsx
import React, { useState } from 'react'

export function TaskForm() {
  const [prompt, setPrompt] = useState('')
  const [repoUrl, setRepoUrl] = useState('')
  // ✗ No validation
  // ✗ No Zod schema binding
  // ✗ No error handling
  // ✗ No type safety

  return (
    <form onSubmit={() => {
      // ✗ No validation before submit
      fetch('/api/tasks', {
        method: 'POST',
        body: JSON.stringify({ prompt, repoUrl }),
      })
    }}>
      <input
        value={prompt}
        onChange={(e) => setPrompt(e.target.value)}
        placeholder="What should I do?"
        // ✗ No label
        // ✗ No error message display
      />
      <input
        value={repoUrl}
        onChange={(e) => setRepoUrl(e.target.value)}
        placeholder="Repo URL"
        // ✗ No URL validation
      />
      <button>Create Task</button>
    </form>
  )
}
```

### After: Component Architect Generated
```typescript
// ✓ AFTER: Full-featured form with validation (generated)
// components/task-form.tsx
import React from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { insertTaskSchema } from '@/lib/db/schema'
import { toast } from 'sonner'
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form'
import {
  Input,
  Button,
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
  Checkbox,
  Label,
  Switch,
} from '@/components/ui'
import { createTask } from '@/lib/actions/tasks'
import { LoadingSpinner } from '@/components/loading-spinner'

type InsertTask = z.infer<typeof insertTaskSchema>

export function TaskForm() {
  // ✓ Full Zod validation with react-hook-form
  const form = useForm<InsertTask>({
    resolver: zodResolver(insertTaskSchema),
    defaultValues: {
      prompt: '',
      repoUrl: '',
      selectedAgent: 'claude',
      installDependencies: false,
      maxDuration: 300,
      keepAlive: false,
    },
  })

  async function onSubmit(data: InsertTask) {
    // ✓ Server action with type safety
    const result = await createTask(data)

    if (result.success) {
      toast.success('Task created successfully')
      form.reset()
    } else {
      toast.error(result.error || 'Failed to create task')
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        {/* ✓ Prompt field with validation */}
        <FormField
          control={form.control}
          name="prompt"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Task Description</FormLabel>
              <FormControl>
                <Input
                  {...field}
                  placeholder="What should I do?"
                  className="h-10"
                  disabled={form.formState.isSubmitting}
                  aria-describedby="prompt-description"
                />
              </FormControl>
              <FormDescription id="prompt-description">
                Describe what you want the AI to accomplish
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* ✓ Repository URL with URL validation */}
        <FormField
          control={form.control}
          name="repoUrl"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Repository URL</FormLabel>
              <FormControl>
                <Input
                  {...field}
                  type="url"
                  placeholder="https://github.com/owner/repo"
                  disabled={form.formState.isSubmitting}
                  aria-describedby="repo-description"
                />
              </FormControl>
              <FormDescription id="repo-description">
                GitHub repository URL (public or with access)
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* ✓ Agent selection dropdown */}
        <FormField
          control={form.control}
          name="selectedAgent"
          render={({ field }) => (
            <FormItem>
              <FormLabel>AI Agent</FormLabel>
              <Select
                onValueChange={field.onChange}
                defaultValue={field.value}
                disabled={form.formState.isSubmitting}
              >
                <FormControl>
                  <SelectTrigger aria-label="Select AI agent">
                    <SelectValue placeholder="Choose an agent" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="claude">Claude Code</SelectItem>
                  <SelectItem value="codex">OpenAI Codex</SelectItem>
                  <SelectItem value="copilot">GitHub Copilot</SelectItem>
                  <SelectItem value="cursor">Cursor</SelectItem>
                  <SelectItem value="gemini">Google Gemini</SelectItem>
                  <SelectItem value="opencode">OpenCode</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* ✓ Dependency installation checkbox */}
        <FormField
          control={form.control}
          name="installDependencies"
          render={({ field }) => (
            <FormItem className="flex items-center space-x-2">
              <FormControl>
                <Checkbox
                  checked={field.value}
                  onCheckedChange={field.onChange}
                  disabled={form.formState.isSubmitting}
                  id="install-deps"
                />
              </FormControl>
              <Label htmlFor="install-deps">
                Install dependencies (npm/pnpm/yarn)
              </Label>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* ✓ Max duration select */}
        <FormField
          control={form.control}
          name="maxDuration"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Sandbox Timeout</FormLabel>
              <Select
                onValueChange={(v) => field.onChange(parseInt(v))}
                defaultValue={field.value?.toString()}
                disabled={form.formState.isSubmitting}
              >
                <FormControl>
                  <SelectTrigger aria-label="Select timeout">
                    <SelectValue />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="300">5 minutes</SelectItem>
                  <SelectItem value="900">15 minutes</SelectItem>
                  <SelectItem value="1800">30 minutes</SelectItem>
                  <SelectItem value="3600">1 hour</SelectItem>
                  <SelectItem value="18000">5 hours</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* ✓ Keep alive toggle */}
        <FormField
          control={form.control}
          name="keepAlive"
          render={({ field }) => (
            <FormItem className="flex items-center justify-between">
              <div>
                <FormLabel>Keep Sandbox Alive</FormLabel>
                <FormDescription>
                  Keep the sandbox running for follow-up messages
                </FormDescription>
              </div>
              <FormControl>
                <Switch
                  checked={field.value}
                  onCheckedChange={field.onChange}
                  disabled={form.formState.isSubmitting}
                  aria-label="Toggle keep alive"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* ✓ Submit button with loading state */}
        <Button
          type="submit"
          disabled={form.formState.isSubmitting}
          className="w-full"
        >
          {form.formState.isSubmitting ? (
            <>
              <LoadingSpinner className="mr-2" />
              Creating...
            </>
          ) : (
            'Create Task'
          )}
        </Button>
      </form>
    </Form>
  )
}
```

### Key Improvements
| Feature | Before | After |
|---------|--------|-------|
| Validation | ✗ None | ✓ Zod schema |
| Error messages | ✗ None | ✓ Field-level |
| Type safety | ✗ Any types | ✓ Full inference |
| Accessibility | ✗ No labels | ✓ WCAG 2.1 AA |
| Loading state | ✗ None | ✓ Built-in |
| Disabled state | ✗ None | ✓ On submit |
| UI components | ✗ HTML elements | ✓ shadcn/ui |

---

## Summary: What Gets Generated

### API Route Architect Produces
- ✓ Complete route handler (GET, POST, PATCH, DELETE)
- ✓ Session validation + rate limiting
- ✓ Zod schemas for request/response
- ✓ User-scoped database queries
- ✓ Proper HTTP status codes
- ✓ Static-string logging
- ✓ TypeScript types

### Database Optimizer Produces
- ✓ Complete table definition
- ✓ Foreign key relationships + cascades
- ✓ Zod insert/select schemas
- ✓ Query helper functions
- ✓ SQL migration file
- ✓ Index recommendations

### Security Enforcer Produces
- ✓ Audit report (violations + fixes)
- ✓ Refactored code (static strings, encryption)
- ✓ Updated redaction patterns
- ✓ Compliance checklist
- ✓ Training documentation

### Sandbox Manager Produces
- ✓ Unified agent executor template
- ✓ Error recovery helpers
- ✓ Session management utilities
- ✓ Refactored agent implementations
- ✓ State machine documentation

### Component Library Produces
- ✓ Complete React components (shadcn/ui)
- ✓ Form builders with validation
- ✓ TypeScript prop types
- ✓ Accessibility audit + fixes
- ✓ Component documentation

---

**Ready to use these examples?** See `SUBAGENTS_QUICK_START.md` for invocation patterns.

**Last Updated:** January 15, 2026
